// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: applications.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const countApplicationsByStatusAndUserID = `-- name: CountApplicationsByStatusAndUserID :one
SELECT COUNT(*) FROM applications
WHERE status = $1 AND user_id = $2
`

type CountApplicationsByStatusAndUserIDParams struct {
	Status string `json:"status"`
	UserID int32  `json:"user_id"`
}

// Get total count of applications with a specific status for a specific user
func (q *Queries) CountApplicationsByStatusAndUserID(ctx context.Context, arg CountApplicationsByStatusAndUserIDParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countApplicationsByStatusAndUserID, arg.Status, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countApplicationsByUserID = `-- name: CountApplicationsByUserID :one
SELECT COUNT(*) FROM applications
WHERE user_id = $1
`

// Get total count of applications for a specific user
func (q *Queries) CountApplicationsByUserID(ctx context.Context, userID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, countApplicationsByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createApplication = `-- name: CreateApplication :one
INSERT INTO applications (status, applied_date, notes, contact_id, user_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, status, applied_date, notes, created_at, updated_at, contact_id, user_id
`

type CreateApplicationParams struct {
	Status      string         `json:"status"`
	AppliedDate time.Time      `json:"applied_date"`
	Notes       sql.NullString `json:"notes"`
	ContactID   sql.NullInt32  `json:"contact_id"`
	UserID      int32          `json:"user_id"`
}

// Create a new application and return the created record
// Note: job_id is no longer needed, jobs will reference applications
// contact_id is optional
func (q *Queries) CreateApplication(ctx context.Context, arg CreateApplicationParams) (Application, error) {
	row := q.db.QueryRowContext(ctx, createApplication,
		arg.Status,
		arg.AppliedDate,
		arg.Notes,
		arg.ContactID,
		arg.UserID,
	)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.AppliedDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactID,
		&i.UserID,
	)
	return i, err
}

const deleteApplication = `-- name: DeleteApplication :exec
DELETE FROM applications
WHERE id = $1 AND user_id = $2
`

type DeleteApplicationParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

// Delete an application by ID (verifies ownership via user_id)
func (q *Queries) DeleteApplication(ctx context.Context, arg DeleteApplicationParams) error {
	_, err := q.db.ExecContext(ctx, deleteApplication, arg.ID, arg.UserID)
	return err
}

const getApplicationByIDAndUserID = `-- name: GetApplicationByIDAndUserID :one
SELECT id, status, applied_date, notes, created_at, updated_at, contact_id, user_id FROM applications
WHERE id = $1 AND user_id = $2
`

type GetApplicationByIDAndUserIDParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

// Get a single application by ID and user_id (ownership verification)
func (q *Queries) GetApplicationByIDAndUserID(ctx context.Context, arg GetApplicationByIDAndUserIDParams) (Application, error) {
	row := q.db.QueryRowContext(ctx, getApplicationByIDAndUserID, arg.ID, arg.UserID)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.AppliedDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactID,
		&i.UserID,
	)
	return i, err
}

const getApplicationsByStatusAndUserID = `-- name: GetApplicationsByStatusAndUserID :many
SELECT id, status, applied_date, notes, created_at, updated_at, contact_id, user_id FROM applications
WHERE status = $1 AND user_id = $2
ORDER BY updated_at DESC NULLS LAST, created_at DESC
`

type GetApplicationsByStatusAndUserIDParams struct {
	Status string `json:"status"`
	UserID int32  `json:"user_id"`
}

// Get all applications with a specific status for a specific user
func (q *Queries) GetApplicationsByStatusAndUserID(ctx context.Context, arg GetApplicationsByStatusAndUserIDParams) ([]Application, error) {
	rows, err := q.db.QueryContext(ctx, getApplicationsByStatusAndUserID, arg.Status, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Application
	for rows.Next() {
		var i Application
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.AppliedDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContactID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationsByStatusAndUserIDPaginated = `-- name: GetApplicationsByStatusAndUserIDPaginated :many
SELECT id, status, applied_date, notes, created_at, updated_at, contact_id, user_id FROM applications
WHERE status = $1 AND user_id = $2
ORDER BY updated_at DESC NULLS LAST, created_at DESC
LIMIT $3 OFFSET $4
`

type GetApplicationsByStatusAndUserIDPaginatedParams struct {
	Status string `json:"status"`
	UserID int32  `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

// Get paginated applications with a specific status for a specific user
func (q *Queries) GetApplicationsByStatusAndUserIDPaginated(ctx context.Context, arg GetApplicationsByStatusAndUserIDPaginatedParams) ([]Application, error) {
	rows, err := q.db.QueryContext(ctx, getApplicationsByStatusAndUserIDPaginated,
		arg.Status,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Application
	for rows.Next() {
		var i Application
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.AppliedDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContactID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationsByUserID = `-- name: GetApplicationsByUserID :many
SELECT id, status, applied_date, notes, created_at, updated_at, contact_id, user_id FROM applications
WHERE user_id = $1
ORDER BY updated_at DESC NULLS LAST, created_at DESC
`

// Get all applications for a specific user, ordered by applied_date (newest first)
func (q *Queries) GetApplicationsByUserID(ctx context.Context, userID int32) ([]Application, error) {
	rows, err := q.db.QueryContext(ctx, getApplicationsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Application
	for rows.Next() {
		var i Application
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.AppliedDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContactID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationsByUserIDPaginated = `-- name: GetApplicationsByUserIDPaginated :many
SELECT id, status, applied_date, notes, created_at, updated_at, contact_id, user_id FROM applications
WHERE user_id = $1
ORDER BY updated_at DESC NULLS LAST, created_at DESC
LIMIT $2 OFFSET $3
`

type GetApplicationsByUserIDPaginatedParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Get paginated applications for a specific user, ordered by applied_date (newest first)
func (q *Queries) GetApplicationsByUserIDPaginated(ctx context.Context, arg GetApplicationsByUserIDPaginatedParams) ([]Application, error) {
	rows, err := q.db.QueryContext(ctx, getApplicationsByUserIDPaginated, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Application
	for rows.Next() {
		var i Application
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.AppliedDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContactID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobByApplicationIDAndUserID = `-- name: GetJobByApplicationIDAndUserID :one
SELECT j.id, j.company_id, j.title, j.description, j.requirements, j.location, j.created_at, j.updated_at, j.application_id FROM jobs j
INNER JOIN applications a ON j.application_id = a.id
WHERE j.application_id = $1 AND a.user_id = $2
`

type GetJobByApplicationIDAndUserIDParams struct {
	ApplicationID int32 `json:"application_id"`
	UserID        int32 `json:"user_id"`
}

// Get the job for a specific application (verifies ownership through application's user_id)
func (q *Queries) GetJobByApplicationIDAndUserID(ctx context.Context, arg GetJobByApplicationIDAndUserIDParams) (Job, error) {
	row := q.db.QueryRowContext(ctx, getJobByApplicationIDAndUserID, arg.ApplicationID, arg.UserID)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Title,
		&i.Description,
		&i.Requirements,
		&i.Location,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ApplicationID,
	)
	return i, err
}

const updateApplication = `-- name: UpdateApplication :one
UPDATE applications
SET status = $2,
    applied_date = $3,
    notes = $4,
    contact_id = $5,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND user_id = $6
RETURNING id, status, applied_date, notes, created_at, updated_at, contact_id, user_id
`

type UpdateApplicationParams struct {
	ID          int32          `json:"id"`
	Status      string         `json:"status"`
	AppliedDate time.Time      `json:"applied_date"`
	Notes       sql.NullString `json:"notes"`
	ContactID   sql.NullInt32  `json:"contact_id"`
	UserID      int32          `json:"user_id"`
}

// Update an application and return the updated record (verifies ownership via user_id)
func (q *Queries) UpdateApplication(ctx context.Context, arg UpdateApplicationParams) (Application, error) {
	row := q.db.QueryRowContext(ctx, updateApplication,
		arg.ID,
		arg.Status,
		arg.AppliedDate,
		arg.Notes,
		arg.ContactID,
		arg.UserID,
	)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.AppliedDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactID,
		&i.UserID,
	)
	return i, err
}
