// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: applications.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const countApplications = `-- name: CountApplications :one
SELECT COUNT(*) FROM applications
`

// Get total count of applications
func (q *Queries) CountApplications(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countApplications)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countApplicationsByStatus = `-- name: CountApplicationsByStatus :one
SELECT COUNT(*) FROM applications
WHERE status = $1
`

// Get total count of applications with a specific status
func (q *Queries) CountApplicationsByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countApplicationsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createApplication = `-- name: CreateApplication :one
INSERT INTO applications (job_id, status, applied_date, notes)
VALUES ($1, $2, $3, $4)
RETURNING id, job_id, status, applied_date, notes, created_at, updated_at
`

type CreateApplicationParams struct {
	JobID       int32          `json:"job_id"`
	Status      string         `json:"status"`
	AppliedDate time.Time      `json:"applied_date"`
	Notes       sql.NullString `json:"notes"`
}

// Create a new application and return the created record
func (q *Queries) CreateApplication(ctx context.Context, arg CreateApplicationParams) (Application, error) {
	row := q.db.QueryRowContext(ctx, createApplication,
		arg.JobID,
		arg.Status,
		arg.AppliedDate,
		arg.Notes,
	)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Status,
		&i.AppliedDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteApplication = `-- name: DeleteApplication :exec
DELETE FROM applications
WHERE id = $1
`

// Delete an application by ID
func (q *Queries) DeleteApplication(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteApplication, id)
	return err
}

const getAllApplications = `-- name: GetAllApplications :many
SELECT id, job_id, status, applied_date, notes, created_at, updated_at FROM applications
ORDER BY applied_date DESC
`

// Get all applications, ordered by applied_date (newest first)
func (q *Queries) GetAllApplications(ctx context.Context) ([]Application, error) {
	rows, err := q.db.QueryContext(ctx, getAllApplications)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Application
	for rows.Next() {
		var i Application
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Status,
			&i.AppliedDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllApplicationsPaginated = `-- name: GetAllApplicationsPaginated :many
SELECT id, job_id, status, applied_date, notes, created_at, updated_at FROM applications
ORDER BY applied_date DESC
LIMIT $1 OFFSET $2
`

type GetAllApplicationsPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Get paginated applications, ordered by applied_date (newest first)
func (q *Queries) GetAllApplicationsPaginated(ctx context.Context, arg GetAllApplicationsPaginatedParams) ([]Application, error) {
	rows, err := q.db.QueryContext(ctx, getAllApplicationsPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Application
	for rows.Next() {
		var i Application
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Status,
			&i.AppliedDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationByID = `-- name: GetApplicationByID :one
SELECT id, job_id, status, applied_date, notes, created_at, updated_at FROM applications
WHERE id = $1
`

// Get a single application by ID
func (q *Queries) GetApplicationByID(ctx context.Context, id int32) (Application, error) {
	row := q.db.QueryRowContext(ctx, getApplicationByID, id)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Status,
		&i.AppliedDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getApplicationsByJobID = `-- name: GetApplicationsByJobID :many
SELECT id, job_id, status, applied_date, notes, created_at, updated_at FROM applications
WHERE job_id = $1
ORDER BY applied_date DESC
`

// Get all applications for a specific job
func (q *Queries) GetApplicationsByJobID(ctx context.Context, jobID int32) ([]Application, error) {
	rows, err := q.db.QueryContext(ctx, getApplicationsByJobID, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Application
	for rows.Next() {
		var i Application
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Status,
			&i.AppliedDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationsByStatus = `-- name: GetApplicationsByStatus :many
SELECT id, job_id, status, applied_date, notes, created_at, updated_at FROM applications
WHERE status = $1
ORDER BY applied_date DESC
`

// Get all applications with a specific status
func (q *Queries) GetApplicationsByStatus(ctx context.Context, status string) ([]Application, error) {
	rows, err := q.db.QueryContext(ctx, getApplicationsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Application
	for rows.Next() {
		var i Application
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Status,
			&i.AppliedDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateApplication = `-- name: UpdateApplication :one
UPDATE applications
SET status = $2,
    applied_date = $3,
    notes = $4,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, job_id, status, applied_date, notes, created_at, updated_at
`

type UpdateApplicationParams struct {
	ID          int32          `json:"id"`
	Status      string         `json:"status"`
	AppliedDate time.Time      `json:"applied_date"`
	Notes       sql.NullString `json:"notes"`
}

// Update an application and return the updated record
func (q *Queries) UpdateApplication(ctx context.Context, arg UpdateApplicationParams) (Application, error) {
	row := q.db.QueryRowContext(ctx, updateApplication,
		arg.ID,
		arg.Status,
		arg.AppliedDate,
		arg.Notes,
	)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Status,
		&i.AppliedDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
