// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: applications.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const countApplications = `-- name: CountApplications :one
SELECT COUNT(*) FROM applications
`

// Get total count of applications
func (q *Queries) CountApplications(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countApplications)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countApplicationsByStatus = `-- name: CountApplicationsByStatus :one
SELECT COUNT(*) FROM applications
WHERE status = $1
`

// Get total count of applications with a specific status
func (q *Queries) CountApplicationsByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countApplicationsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createApplication = `-- name: CreateApplication :one
INSERT INTO applications (status, applied_date, notes, contact_id)
VALUES ($1, $2, $3, $4)
RETURNING id, status, applied_date, notes, created_at, updated_at, contact_id
`

type CreateApplicationParams struct {
	Status      string         `json:"status"`
	AppliedDate time.Time      `json:"applied_date"`
	Notes       sql.NullString `json:"notes"`
	ContactID   sql.NullInt32  `json:"contact_id"`
}

// Create a new application and return the created record
// Note: job_id is no longer needed, jobs will reference applications
// contact_id is optional
func (q *Queries) CreateApplication(ctx context.Context, arg CreateApplicationParams) (Application, error) {
	row := q.db.QueryRowContext(ctx, createApplication,
		arg.Status,
		arg.AppliedDate,
		arg.Notes,
		arg.ContactID,
	)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.AppliedDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactID,
	)
	return i, err
}

const deleteApplication = `-- name: DeleteApplication :exec
DELETE FROM applications
WHERE id = $1
`

// Delete an application by ID
func (q *Queries) DeleteApplication(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteApplication, id)
	return err
}

const getAllApplications = `-- name: GetAllApplications :many
SELECT id, status, applied_date, notes, created_at, updated_at, contact_id FROM applications
ORDER BY applied_date DESC
`

// Get all applications, ordered by applied_date (newest first)
func (q *Queries) GetAllApplications(ctx context.Context) ([]Application, error) {
	rows, err := q.db.QueryContext(ctx, getAllApplications)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Application
	for rows.Next() {
		var i Application
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.AppliedDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContactID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllApplicationsPaginated = `-- name: GetAllApplicationsPaginated :many
SELECT id, status, applied_date, notes, created_at, updated_at, contact_id FROM applications
ORDER BY applied_date DESC
LIMIT $1 OFFSET $2
`

type GetAllApplicationsPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Get paginated applications, ordered by applied_date (newest first)
func (q *Queries) GetAllApplicationsPaginated(ctx context.Context, arg GetAllApplicationsPaginatedParams) ([]Application, error) {
	rows, err := q.db.QueryContext(ctx, getAllApplicationsPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Application
	for rows.Next() {
		var i Application
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.AppliedDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContactID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationByID = `-- name: GetApplicationByID :one
SELECT id, status, applied_date, notes, created_at, updated_at, contact_id FROM applications
WHERE id = $1
`

// Get a single application by ID
func (q *Queries) GetApplicationByID(ctx context.Context, id int32) (Application, error) {
	row := q.db.QueryRowContext(ctx, getApplicationByID, id)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.AppliedDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactID,
	)
	return i, err
}

const getApplicationsByStatus = `-- name: GetApplicationsByStatus :many
SELECT id, status, applied_date, notes, created_at, updated_at, contact_id FROM applications
WHERE status = $1
ORDER BY applied_date DESC
`

// Get all applications with a specific status
func (q *Queries) GetApplicationsByStatus(ctx context.Context, status string) ([]Application, error) {
	rows, err := q.db.QueryContext(ctx, getApplicationsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Application
	for rows.Next() {
		var i Application
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.AppliedDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContactID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationsByStatusPaginated = `-- name: GetApplicationsByStatusPaginated :many
SELECT id, status, applied_date, notes, created_at, updated_at, contact_id FROM applications
WHERE status = $1
ORDER BY applied_date DESC
LIMIT $2 OFFSET $3
`

type GetApplicationsByStatusPaginatedParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

// Get paginated applications with a specific status
func (q *Queries) GetApplicationsByStatusPaginated(ctx context.Context, arg GetApplicationsByStatusPaginatedParams) ([]Application, error) {
	rows, err := q.db.QueryContext(ctx, getApplicationsByStatusPaginated, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Application
	for rows.Next() {
		var i Application
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.AppliedDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContactID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobByApplicationID = `-- name: GetJobByApplicationID :one
SELECT id, company_id, title, description, requirements, location, created_at, updated_at, application_id FROM jobs
WHERE application_id = $1
`

// Get the job for a specific application
func (q *Queries) GetJobByApplicationID(ctx context.Context, applicationID int32) (Job, error) {
	row := q.db.QueryRowContext(ctx, getJobByApplicationID, applicationID)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Title,
		&i.Description,
		&i.Requirements,
		&i.Location,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ApplicationID,
	)
	return i, err
}

const updateApplication = `-- name: UpdateApplication :one
UPDATE applications
SET status = $2,
    applied_date = $3,
    notes = $4,
    contact_id = $5,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, status, applied_date, notes, created_at, updated_at, contact_id
`

type UpdateApplicationParams struct {
	ID          int32          `json:"id"`
	Status      string         `json:"status"`
	AppliedDate time.Time      `json:"applied_date"`
	Notes       sql.NullString `json:"notes"`
	ContactID   sql.NullInt32  `json:"contact_id"`
}

// Update an application and return the updated record
func (q *Queries) UpdateApplication(ctx context.Context, arg UpdateApplicationParams) (Application, error) {
	row := q.db.QueryRowContext(ctx, updateApplication,
		arg.ID,
		arg.Status,
		arg.AppliedDate,
		arg.Notes,
		arg.ContactID,
	)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.AppliedDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactID,
	)
	return i, err
}
